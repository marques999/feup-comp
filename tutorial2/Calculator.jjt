// 2. Depois de uma primeira utilização do JavaCC vamos agora// ver como se pode gerar automaticamente a árvore sintáctica.// Para tal utilizaremos o JJTree. O JJTree é uma ferramenta de// pré-processamento integrada no pacote de software JavaCC que// gera classes Java e um ficheiro para o JavaCC que, para além// da descrição da gramática, integra código Java para a geração// da árvore sintáctica. O ficheiro de entrada do JJTree é um// ficheiro que especifica a gramática do mesmo modo que para o// JavaCC e que adicionalmente inclui directivas para a geração// dos nós da árvore (é utilizado jjt como extensão do ficheiro// de entrada do JJTree).options{  LOOKAHEAD= 1;}PARSER_BEGIN(Calculator)public class Calculator{  public static void main(String args []) throws ParseException  {    Calculator myCalc = new Calculator(System.in);    SimpleNode root = myCalc.Expression();    root.dump("");    System.out.println("Valor da expressão: " + myCalc.eval(root));  }  int eval(SimpleNode node)  {    if (node.jjtGetNumChildren() == 0) // leaf node with integer value      return node.val;    else if (node.jjtGetNumChildren() == 1) // only one child      return this.eval((SimpleNode) node.jjtGetChild(0));    SimpleNode lhs = (SimpleNode) node.jjtGetChild(0); //left child    SimpleNode rhs = (SimpleNode) node.jjtGetChild(1); // right child    switch (node.id)    {      case CalculatorTreeConstants.JJTADD : return eval(lhs) + eval(rhs);      case CalculatorTreeConstants.JJTSUB : return eval(lhs) - eval(rhs);      case CalculatorTreeConstants.JJTMUL : return eval(lhs) * eval(rhs);      case CalculatorTreeConstants.JJTDIV : return eval(lhs) / eval(rhs);      default:      	System.out.println("Operador ilegal!");      	System.exit(1);    }    return 0;  }}PARSER_END(Calculator)SKIP :{  " " | "\r" | "\t"}TOKEN :{  < INTEGER : ([ "0"-"9" ])+ > | < LF : "\n" >}SimpleNode Expression() :{}{  Expr1() < LF >  {    return jjtThis;  }}void Expr1() #void :{}{  Expr2(1)  [      "+" Expr2(1) #Add(2)      |      "-" Expr2(1) #Sub(2)  ]}void Expr2(int sign) #void :{}{  Expr3(sign)  [	"*" Expr3(1) #Mul(2)	|	"/" Expr3(1) #Div(2)  ]}void Expr3(int sign) #void :{  Token t;}{  t = < INTEGER >  {    jjtThis.val = sign * Integer.parseInt(t.image);  } #Term  |  "-" Expr3(-1)  |  "(" Expr1() ")"}